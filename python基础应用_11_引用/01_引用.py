# -*- coding: utf-8 -*-
"""
@author : xiaoxinxin
@date : 2021/8/4 - 11:13
@file : 01_引用.py
@ide : PyCharm
"""
"""
# 整型是不可变的数据类型
a = 1
b = a
print(b)
print(a)
print(id(a))
print(id(b))
a = 2
print(a)
print(b)  # 整型是不可变的数据类型
print(id(a))
print(id(b))

# 列表是可变的数据类型
list_1 = [1, 2, 3]
list_2 = list_1
print(list_1)
print(list_2)
print(id(list_1))
print(id(list_2))
list_1.append(4)
print(list_1)
print(list_2)  # 列表是一个可变数据类型
print(id(list_1))
print(id(list_2))


# 引用作为实参
def test1(a):
    print(a)
    print(id(a))
    a += a
    print(a)
    print(id(a))


b = 100
test1(b)
c = [11, 22]
test1(c)
"""

"""
举第一个栗子：

a = 1

这是一个简单的赋值语句，整数 1 为一个对象，a 是一个引用，利用赋值语句，引用a指向了对象1；这边形象比喻一下：这个过程就相当于“放风筝”，变量a就是你手里面的“线”，python就跟那根“线”一样，通过引用来接触和拴住天空中的风筝——对象。

你可以通过python的内置函数 id() 来查看对象的身份(identity)，这个所谓的身份其实就是 对象 的内存地址：

注：

python一切皆对象的理念，所以函数也是一个对象，因此可以使用 id() 函数的__doc__方法来查看这个函数的具体描述：

>>> id.__doc__

"id(object) -> integer\n\nReturn the identity of an object. This is guaranteed to be unique among\nsimultaneously existing objects. 　　　　　　(Hint: it's the object's memory address.)"

第二个栗子：

a = 2

a = 'banana'

利用上面第一个栗子用到的 id()函数：

>>> a = 1

>>> id(a)

24834392

>>> a = 'banana'

>>> id(a)

139990659655312

第一个语句中， 2是储存在内存中的一个整数对象，通过赋值 引用a 指向了 对象 1

第二个语句中，内存中建立了一个字符串对象‘banana’，通过赋值 将 引用a 指向了 ‘banana’，同时，对象1不在有引用指向它，它会被python的内存处理机制给当我垃圾回收，释放内存。

第三个栗子：

a = 3

b = 3

通过函数查看 变量a 和 变量b的引用情况：

>>> a = 3

>>> b = 3

>>> id(a)

10289448

>>> id(b)

10289448

在这里可以看到 这俩个引用 指向了同一个 对象，这是为什么呢？ 这个跟python的内存机制有关系，因为对于语言来说，频繁的进行对象的销毁和建立，特别浪费性能。所以在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。

第四个栗子：

1. a = 4

2. b = a（这里就是让引用b指向引用a指向的那个对象）

3. a = a + 2

通过函数查看引用情况：

当执行到第2步的时候，查看一下 a 和 b 的引用：

>>> a = 4

>>> b = a

>>> id(a)

36151568

>>> id(b)

36151568

可以看到 a 和 b 都指向了 整数对象 4

接下来指向第3步：

>>> a = a+2

>>> id(a)

36151520

>>> id(b)

36151568

可以看到 a 的引用改变了，但是 b 的引用未发生改变；a，b指向不同的对象； 第3句对 a 进行了重新赋值，让它指向了新的 对象6；即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用指向一个新的引用，并不影响其他的引用的指向。从效果上看，就是各个引用各自独立，互不影响。

第五个栗子（这个栗子会涉及到 python中的 可变数据类型 和 不可变数据类型）：

开始这个栗子之前，请记得注意到 第四个栗子的不同之处。

1. L1 = [1, 2, 3]

2. L2 = L1

3. L1[0] = 10

通过函数查看引用情况：

当执行第1步 和 第二步 的时候，查看一下 L1 和 L2 的引用情况：

>>> L1 = [1,2,3]

>>> L2 = L1

>>> id(L1)

139643051219496

>>> id(L2)

139643051219496

此时 L1 和 L2 的引用相同，都是指向 [1,2,3]这个列表对象。

接下来，继续执行第3步：

>>> L1[0] = 10

>>> id(L1)

139643051219496

>>> id(L2)

139643051219496

>>> L2

[10, 2, 3]

同样的跟第四个栗子那样，修改了其中一个对象的值，但是可以发现 结果 并不与 第四个栗子那样， 在本次实验中，L1 和 L2 的引用没有发生任何变化，但是 列表对象[1,2,3] 的值 变成了 [10,2,3]（列表对象改变了）

在该情况下，我们不再对L1这一引用赋值，而是对L1所指向的表的元素赋值。结果是，L2也同时发生变化。

原因何在呢？因为L1，L2的指向没有发生变化，依然指向那个表。表实际上是包含了多个引用的对象（每个引用是一个元素，比如L1[0]，L1[1]..., 每个引用指向一个对象，比如1,2,3), 。而L1[0] = 10这一赋值操作，并不是改变L1的指向，而是对L1[0], 也就是表对象的一部份(一个元素)，进行操作，所以所有指向该对象的引用都受到影响。

（与之形成对比的是，我们之前的赋值操作都没有对对象自身发生作用，只是改变引用指向。）

列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)，词典也是这样的数据类型。

而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)。

我们之前学的元组(tuple)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是immutable object.

is关键字：

当然，我们也可以要想知道是否指向同一个对象，我们可以使用 python的 is 关键词，is用于判断两个引用所指的对象是否相同。

就像上述第四个栗子 当进行到 第1步 和 第2步 的时候：

>>> a = 4 ……id(a) = 36151568

>>> b =a ……id(b) = 36151568

>>> a is b

True

当进行到第3步的时候：

>>> a = a + 2 ……id(a) = 36151520

>>> a is b ……id(b) = 36151568

False
"""

a = 1  # 系统开辟一段存储空间，整数对象1就存储在这个空间里面，通过赋值语句使引用a指向整形对象1
print(id(a))
a = 2  # 系统开辟一段存储空间，整数对象1就存储在这个空间里面，原先的存储对象1的空间被回收
print(id(a))
b = a
print(b)
a = 3
print(id(a), id(b))

list1 = [1, 2, 3, 4]
list2 = list1
print(id(list1),  id(list2))
list1.append(5)
print(list1)
print(id(list1),  id(list2))  # 与上面的内存的打印地址是一样的，因为这是可变数类型
